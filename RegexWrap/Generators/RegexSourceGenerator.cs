using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Text;

namespace RegexWrap.Generators
{
    [Generator]
    public class RegexSourceGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new RegexSyntaxReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            if (context.SyntaxReceiver is not RegexSyntaxReceiver receiver)
                return;

            foreach (var methodDeclaration in receiver.Methods)
            {
                var semanticModel = context.Compilation.GetSemanticModel(methodDeclaration.SyntaxTree);
                var methodSymbol = semanticModel.GetDeclaredSymbol(methodDeclaration);
                
                if (methodSymbol == null) continue;

                var regexAttribute = methodSymbol.GetAttributes()
                    .FirstOrDefault(a => a.AttributeClass?.Name == "RegexGeneratedAttribute");

                if (regexAttribute == null) continue;

                var pattern = regexAttribute.ConstructorArguments[0].Value?.ToString();
                if (string.IsNullOrEmpty(pattern)) continue;

                var options = regexAttribute.NamedArguments
                    .FirstOrDefault(kvp => kvp.Key == "Options").Value.Value?.ToString() ?? "None";

                var timeout = regexAttribute.NamedArguments
                    .FirstOrDefault(kvp => kvp.Key == "TimeoutMilliseconds").Value.Value ?? 5000;

                var generatedCode = GenerateRegexMethod(
                    methodSymbol.ContainingNamespace.ToDisplayString(),
                    methodSymbol.ContainingType.Name,
                    methodSymbol.Name,
                    pattern,
                    options,
                    (int)timeout);

                context.AddSource($"{methodSymbol.ContainingType.Name}.{methodSymbol.Name}.g.cs", generatedCode);
            }
        }

        private static string GenerateRegexMethod(string namespaceName, string className, string methodName, 
            string pattern, string options, int timeout)
        {
            var code = new StringBuilder();
            
            code.AppendLine("// <auto-generated />");
            code.AppendLine("using System.Text.RegularExpressions;");
            code.AppendLine();
            code.AppendLine($"namespace {namespaceName}");
            code.AppendLine("{");
            code.AppendLine($"    partial class {className}");
            code.AppendLine("    {");
            
            // Use .NET 9's native GeneratedRegex for better performance
            code.AppendLine($"        [GeneratedRegex(@\"{EscapeString(pattern)}\", RegexOptions.{options}, {timeout})]");
            code.AppendLine($"        public static partial Regex {methodName}();");
            
            code.AppendLine("    }");
            code.AppendLine("}");

            return code.ToString();
        }

        private static string EscapeString(string input)
        {
            return input.Replace("\"", "\\\"").Replace("\\", "\\\\");
        }
    }

    internal class RegexSyntaxReceiver : ISyntaxReceiver
    {
        public List<MethodDeclarationSyntax> Methods { get; } = new List<MethodDeclarationSyntax>();

        public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
        {
            if (syntaxNode is MethodDeclarationSyntax methodDeclaration 
                && methodDeclaration.Modifiers.Any(SyntaxKind.PartialKeyword)
                && methodDeclaration.AttributeLists.Any())
            {
                Methods.Add(methodDeclaration);
            }
        }
    }
}